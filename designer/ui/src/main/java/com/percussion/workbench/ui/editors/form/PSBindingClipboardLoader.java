/******************************************************************************
 *
 * [ PSBindingClipboardLoader.java ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
package com.percussion.workbench.ui.editors.form;

import com.percussion.services.assembly.data.PSTemplateBinding;
import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.commons.logging.LogFactory;
import org.eclipse.swt.dnd.Clipboard;
import org.eclipse.swt.dnd.TextTransfer;
import org.eclipse.swt.dnd.Transfer;
import org.eclipse.swt.widgets.Display;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;

/**
 * Loads template bindings to, reads from Eclipse clipboard.
 *
 * @author Andriy Palamarchuk
 *
 */
class PSBindingClipboardLoader
{
   /**
    * The class log.
    */
   private final static Logger ms_log = LogManager.getLogger(
         PSBindingClipboardLoader.class); 
   
   /**
    * Creates new loader.
    * @param display the display to use to access clipboard.
    * Not <code>null</code>.
    */
   public PSBindingClipboardLoader(final Display display)
   {
      if (display == null)
      {
         throw new IllegalArgumentException("Display should not be null");
      }
      m_display = display;
   }

   /**
    * Indicates whether clipboard contains valid bindings.
    * @return <code>true</code> if clipboard contains data recognized as
    * valid bindings.
    */
   public boolean clipboardContainsBindings()
   {
      final Properties properties = getClipboardData(getClipboardContent());
      return properties != null && StringUtils.equals(
            properties.getProperty(CLIPBOARD_ID_PROP),
            BINDINGS_CLIPBOARD_ID);
   }
   
   /**
    * Copies provided bindings to clipboard.
    * @param bindings the bindings to copy to clipboard.
    * Does nothing if <code>null</code> or empty.
    */
   public void copyBindings(final List<PSTemplateBinding> bindings)
   {
      if (bindings == null || bindings.isEmpty())
      {
         return;
      }
      final String content = toClipboardFormat(bindings);
      final Clipboard clipboard = new Clipboard(m_display);
      try
      {
         clipboard.setContents(new String[] {content},
               new Transfer[] {TextTransfer.getInstance()});
      }
      finally
      {
         clipboard.dispose();
      }
   }

   /**
    * Reads bindings from clipboard.
    * Does nothing if the clipboard is empty or clipboard content is not 
    * recognized to be bindings. Invalid binding data is ignored during the
    * operation.
    */
   public List<PSTemplateBinding> pasteBindings()
   {
      if (!clipboardContainsBindings())
      {
         return null;
      }
      return dataToBindings(getClipboardData(getClipboardContent()));
   }

   /**
    * Creates bindings from bindings data. Bindings data here are properties
    * loaded from string generated by {@link #toClipboardFormat(List)}.
    * Unrecognized data is ignored.
    * @param properties the bindings data as properties.
    * Assumed not <code>null</code>.
    * @return list of bindings generated from the data.
    * Can be empty, never <code>null</code>.
    */
   @SuppressWarnings("unchecked")
   private List<PSTemplateBinding> dataToBindings(final Properties properties)
   {
      final Set<String> nameSet = new HashSet(properties.keySet());
      nameSet.remove(CLIPBOARD_ID_PROP);

      final List<String> propertyNames = new ArrayList<String>(nameSet);
      Collections.sort(propertyNames);

      final List<PSTemplateBinding> bindings =
            new ArrayList<PSTemplateBinding>();

      // new binding for each name,
      // value is assigned to the last created binding
      PSTemplateBinding binding = null;
      for (final String propertyName : propertyNames)
      {
         if (propertyName.endsWith(NAME_PROP_SUFFIX))
         {
            binding = new PSTemplateBinding();
            bindings.add(binding);
            binding.setVariable(properties.getProperty(propertyName));
         }
         else if (propertyName.endsWith(VALUE_PROP_SUFFIX))
         {
            if (binding == null)
            {
               ms_log.warn("Got binding value \""
                     + properties.getProperty(propertyName)
                     + "\" before binding name while reading bindings from "
                     + "clipboard");
               continue;
            }
            binding.setExpression(properties.getProperty(propertyName));
         }
         else
         {
            ms_log.warn("Unrecognized property name: " + propertyName);
         }
      }
      return bindings;
   }

   /**
    * Creates a string presentation of the bindings list for passing
    * to clipboard. The string stores values in {@link Properties} format.
    * Property {@link #CLIPBOARD_ID_PROP} has value
    * {@link #BINDINGS_CLIPBOARD_ID} to identify clipboard content as list of
    * bindings.
    * @param bindings bindings to convert to the clipboard format.
    * Assumed not <code>null</code>.
    * @return a string storing bindings to pass through clipboard.
    * Empty when the bindings list is empty.
    * Never <code>null</code>. 
    */
   private String toClipboardFormat(List<PSTemplateBinding> bindings)
   {
      final Properties properties = new Properties();
      properties.setProperty(CLIPBOARD_ID_PROP, BINDINGS_CLIPBOARD_ID);
      final int padSize = Integer.toString(bindings.size() + 1).length();
      int i = 0;
      for (PSTemplateBinding binding : bindings)
      {
         // Make indexes ordered alphabetically, not just numerically.
         // Otherwise index '2' comes after '10'.
         final String idxStr =
               StringUtils.leftPad(Integer.toString(i), padSize, '0');
         properties.setProperty(
               idxStr + NAME_PROP_SUFFIX, binding.getVariable());
         properties.setProperty(
               idxStr + VALUE_PROP_SUFFIX, binding.getExpression());
         i++;
      }

      final ByteArrayOutputStream out = new ByteArrayOutputStream();
      try
      {
         properties.store(out, null);
         return out.toString();
      }
      catch (IOException e)
      {
         // should never happen because we work in memory
         throw new AssertionError(e);
      }
      finally
      {
         try
         {
            out.close();
         }
         catch (IOException e)
         {
            // should never happen because we work in memory
            throw new AssertionError(e);
         }
      }
   }

   /**
    * Parses the text to properties storing data of bindings list.
    * @param text the text to parse. Can be <code>null</code>.
    * @return properties parsed from the provided string or <code>null</code>
    * if the content of the string can't be recognized as storing
    * list of bindings or the supplied string is blank.
    */
   private Properties getClipboardData(final String text)
   {
      if (StringUtils.isEmpty(text))
      {
         return null;
      }
      final InputStream textStream =
            new ByteArrayInputStream(text.getBytes());
      final Properties properties = new Properties();
      try
      {
         properties.load(textStream);
      }
      catch (IOException e)
      {
         // should not happen because we read from memory
         throw new AssertionError(e);
      }
      catch (IllegalArgumentException e)
      {
         return null;
      }
      finally
      {
         try
         {
            textStream.close();
         }
         catch (IOException e)
         {
            // should not happen because this is in-memory stream
            throw new AssertionError(e);
         }
      }
      return properties;
   }

   /**
    * Reads text from clipboard.
    * @return text from clipboard. <code>null</code> if there is no text
    * content in clipboard.
    */
   private String getClipboardContent()
   {
      final Clipboard clipboard = new Clipboard(m_display);
      try
      {
         return (String) clipboard.getContents(TextTransfer.getInstance());
      }
      finally
      {
         clipboard.dispose();
      }
   }

   /**
    * Name of the property identifying clipboard content.
    */
   private static final String CLIPBOARD_ID_PROP = "clipboard.id";

   /**
    * String identifying clipboard content as list of template bindings. 
    */
   private static final String BINDINGS_CLIPBOARD_ID =
         "com.percussion.services.assembly.data.PSTemplateBinding.BINDINGS";

   /**
    * Suffix of property name storing binding value.
    */
   private static final String VALUE_PROP_SUFFIX = ".value";

   /**
    * Suffix of property name storing binding name.
    */
   private static final String NAME_PROP_SUFFIX = ".name";

   /**
    * Display used by the loader to access clipboard. Never <code>null</code>.
    */
   private final Display m_display;
}
