/******************************************************************************
 *
 * [ PSHierarchyDefProcessor.java ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
package com.percussion.workbench.ui.views.hierarchy;

import com.percussion.client.IPSHierarchyNodeRef;
import com.percussion.client.IPSReference;
import com.percussion.client.PSCoreFactory;
import com.percussion.client.PSModelException;
import com.percussion.client.PSObjectType;
import com.percussion.client.PSObjectTypes;
import com.percussion.client.models.IPSCmsModel;
import com.percussion.client.models.IPSHierarchyManager;
import com.percussion.workbench.ui.IPSCatalog;
import com.percussion.workbench.ui.IPSCatalogFactory;
import com.percussion.workbench.ui.PSMessages;
import com.percussion.workbench.ui.PSUiReference;
import com.percussion.workbench.ui.PSUiReference.SortOrder;
import com.percussion.workbench.ui.handlers.PSIconNodeHandler;
import com.percussion.workbench.ui.model.IPSDeclarativeNodeHandler;
import com.percussion.workbench.ui.model.IPSDeclarativeNodeHandler.HandlerOptions;
import com.percussion.workbench.ui.model.IPSDeclarativeNodeHandler.HandlerOptions.HandlerOptionSet;
import com.percussion.workbench.ui.model.IPSHomeNodeManager;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.Catalog;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.CatalogProperty;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.Handler;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.InstanceTree;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.Node;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.Node.NodeProperty;
import com.percussion.workbench.ui.views.hierarchy.xmlbind.TreeDef;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.xml.sax.InputSource;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/* This warning is used because this class interfaces with generated code that
 * does not generate type-safe collections. We set these un-typed collections
 * into typed collections because we know they are. 
 */
@SuppressWarnings("unchecked")

/**
 * Presents a model of a tree as defined in an XML file that conforms to the
 * viewHierarchyDef.xsd schema. This model is very flexible. It allows
 * combinations of declaratively defined nodes as well as dynamically cataloged
 * nodes. Catalogs can be by object type, or a class name can be specified.
 * <p>
 * Interprets the contents of a {@link PSTreeDef} object, providing the nodes as
 * defined in the definition. All classes that implement the IPSCatalog
 * interface for dynamic cataloging must implement a ctor with the following
 * signature: <type>(PSUiReference, Map<String,String>), where PSUiReference is
 * an ancestor of the nodes to be generated by this catalog (may be
 * <code>null</code>) and Map contains all CatalogProperty entries that are
 * defined in the def for this catalog. The supplied ancestor is the 'context
 * parent' defined in the def. Generally, this is used when the catalog is
 * providing data that is a part of some object, for example, the list of
 * allowed workflows for a content type. In this case, the context parent would
 * be the content type instance.
 * 
 * @version 6.0
 * @author paulhoward
 */
public class PSHierarchyDefProcessor
{
   /**
    * If a node definition has the 'treeName' attribute set, its value is stored 
    * in the PSUiReference node as a property with this name. The value is 
    * lower-cased before storing.
    */
   public static final String TREE_PROPNAME = "hierarchy_tree_name";

   /**
    * If a node returned by this class is a placeholder of type
    * {@link PSObjectTypes#USER_FILE}, then the node will have a property set
    * on it with this name whose value is the properties inherited by the node
    * when it was created. The class of the stored object is
    * {@link InheritedProperties}.
    */
   public static final String INHERITED_PROPS_PROPNAME = "inheritedProperties";

   /**
    * Used to specify what the UI code should use as the label text. 
    *
    * @author paulhoward
    */
   public enum LabelSource
   {
      /**
       * Use the label provided in the declarative def. If not available, use
       * the object name.
       */
      LABEL_KEY,
      
      /**
       * Use the text returned by {@link IPSReference#getName()}.
       */
      OBJECT_NAME,
      
      /**
       * Use the text returned by {@link IPSReference#getLabelKey()}.
       */
      OBJECT_LABEL
   }
   
   /**
    * The only ctor.
    * 
    * @param name The name of this tree fragment. This becomes the name of the
    * root node. Never <code>null</code> or empty.
    * 
    * @param definition How to build the nodes returned by this object. Never
    * <code>null</code>.
    * 
    * @throws IOException If any problems reading the supplied reader.
    */
   public PSHierarchyDefProcessor(String name, Reader definition)
      throws IOException
   {
      if (StringUtils.isBlank(name))
      {
         throw new IllegalArgumentException("name cannot be null or empty");
      }
      if (null == definition)
      {
         throw new IllegalArgumentException("definition cannot be null");
      }
      
      m_name = name;
      m_treeDef = loadTree(definition);
   }

   /**
    * Builds references as defined by the associated tree definition.
    * 
    * @param parent May be <code>null</code> to get the single root child.
    * 
    * @return Never <code>null</code>, may be empty.
    * 
    * @throws PSModelException If any problems cataloging from the server.
    */
   public List<PSUiReference> getChildren(PSUiReference parent)
      throws PSModelException, PSHierarchyDefinitionException
   {
      List<PSUiReference> results;
      if (null == parent)
      {
         final Catalog catalog = m_treeDef.getCatalog();
         final List<Catalog> catalogs = new ArrayList<Catalog>();
         if (catalog != null)
            catalogs.add(catalog);

         final List<Node> nodes = m_treeDef.getNode();
         final String sorting = m_treeDef.getSorting();

         results = buildChildReferences(parent, sorting,
               nodes, catalogs, null, null, false);
         for (PSUiReference node : results)
         {
            node.setProperty(PSUiReference.ROOT_SORT_ORDER_PROPNAME,
                  mapSortOrder(sorting));
         }
      }
      else
      {
         results = parent.getChildren();
      }
      return results;
   }

   /**
    * This class encapsulates behavior for managing the set of properties that
    * can be inherited from ancestors within the definition.
    *
    * @author paulhoward
    */
   public class InheritedProperties
   {
      /**
       * Basic ctor. Defaults props to empty.
       */
      public InheritedProperties()
      {
         m_catalogProps = new Properties();
         m_allowedTypes = new ArrayList<PSObjectType>();
      }

      /**
       * Construct from existing values.
       * 
       * @param allowedTypesString May be <code>null</code> or empty.
       * 
       * @param propDef May be <code>null</code> or empty.
       * 
       * @throws PSHierarchyDefinitionException If the allowed type strings
       * cannot be converted to object types.
       */
      public InheritedProperties(Collection<String> allowedTypesString,
            Collection<CatalogProperty> propDef)
         throws PSHierarchyDefinitionException
      {
         this();
         doInherit(this, allowedTypesString, propDef);
      }

      /**
       * Copy ctor.
       * 
       * @param props Never <code>null</code>.
       */
      public InheritedProperties(InheritedProperties props)
      {
         this();
         if (null == props)
         {
            throw new IllegalArgumentException("props cannot be null");  
         }
         
         m_catalogProps.putAll(props.m_catalogProps);
         m_allowedTypes.addAll(props.m_allowedTypes);
      }
      
      /**
       * Creates a clone of this object and merges the supplied properties with
       * those already assigned to this object.
       * 
       * @param allowedTypesString If provided, totally replace what the object
       * contains.
       * 
       * @param propDef If provided, any property name that matches an existing
       * one overrides it, otherwise, they are added.
       * 
       * @return The cloned/merged object. This object remains unchanged.
       * 
       * @throws PSHierarchyDefinitionException If the allowed type strings
       * cannot be converted to object types.
       */
      public InheritedProperties inherit(Collection<String> allowedTypesString,
            Collection<CatalogProperty> propDef)
         throws PSHierarchyDefinitionException
      {
         InheritedProperties processedProps = new InheritedProperties(this);
         doInherit(processedProps, allowedTypesString, propDef);
         return processedProps;
      }

      /**
       * Just like {@link #inherit(Collection, Collection)}, except only 
       * properties are provided.
       * 
       * @param props The new properties to inherit. If any names match existing 
       * names, those properties are superceded by the supplied ones.
       * 
       * @return A new instance of this class that is a clone, merged with the
       * supplied properties.
       */
      public InheritedProperties inherit(Map<String,String> props)
      {
         InheritedProperties processedProps = new InheritedProperties(this);
         if (props != null)
         {
            for (String key : props.keySet())
            {
               processedProps.m_catalogProps.setProperty(key, props.get(key));
            }
         }
         return processedProps;
      }
      
      /**
       * Does the work of {@link #inherit(Collection, Collection)}. See that
       * method for more details.
       * 
       * @param props Assumed not <code>null</code>.
       */
      private void doInherit(InheritedProperties props,
            Collection<String> allowedTypesString,
            Collection<CatalogProperty> propDef)
         throws PSHierarchyDefinitionException
      {
         if (allowedTypesString != null && allowedTypesString.size() > 0)
         {
            Collection<PSObjectType> allowedTypes = 
               Arrays.asList(convertStringToObjectType(allowedTypesString));
            props.m_allowedTypes = allowedTypes;
         }
         
         if (null != propDef && propDef.size() > 0)
         {
            for (CatalogProperty type : propDef)
            {
               props.m_catalogProps.setProperty(type.getName(), type
                     .getValue());
            }
         }
      }
      
      /**
       * Returns the allowedTypes of the closest ancestor as originally set in
       * the ctor or inherited from.
       * 
       * @return Never <code>null</code>. Do not edit the returned list.
       */
      public Collection<PSObjectType> getAllowedTypes()
      {
         return m_allowedTypes;
      }

      /**
       * Returns the catalog properties processed for all ancestors.
       * 
       * @return Never <code>null</code>. Do not edit the returned list.
       */
      public Properties getCatalogProps()
      {
         return m_catalogProps;
      }

      //see base class method for details
      @Override
      public boolean equals(Object o)
      {
         if (o == null)
            return false;
         if (!(o instanceof InheritedProperties))
            return false;
         if (o == this)
            return true;
         InheritedProperties rhs = (InheritedProperties) o;
         
         boolean result = new EqualsBuilder()
            .append(m_catalogProps, rhs.m_catalogProps)
            .append(m_allowedTypes, rhs.m_allowedTypes)
            .isEquals();
         return result;
      }

      //see base class method for details
      @Override
      public int hashCode()
      {
         return new HashCodeBuilder()
         .append(m_catalogProps)
         .append(m_allowedTypes)
         .toHashCode();
      }
      
      /**
       * Set in ctor, then modified by {@link #inherit(Collection, Collection)}.
       * Never <code>null</code> after ctor, may be empty.
       */
      private Properties m_catalogProps;

      /**
       * Set in ctor, then modified by {@link #inherit(Collection, Collection)}.
       * Never <code>null</code> after ctor, may be empty.
       */
      private Collection<PSObjectType> m_allowedTypes;
   }
   
   /**
    * 
    * @param parent The owner of the generated children. May be
    * <code>null</code>.
    * @param sortType The value of the 'sorting' attribute. May be null or empty
    * to use ascending sort.
    * @param nodes The list of Node elements from the def for a given parent.
    * May be <code>null</code> or empty.
    * @param catalogs The list of Catalog elements from the def for a given
    * parent. May be <code>null</code> or empty.
    * @param inheritedProps Catalog properties from all ancestors. May be
    * <code>null</code> or empty.
    * @param child This may be used to build the wrapper object for newly create
    * design objects that fit into an already cataloged node. May be
    * <code>null</code>.
    * @param force If <code>true</code>, then the catalog will  query the 
    * server, even if the request could have been serviced from the cache.
    * 
    * @return Never <code>null</code>, may be empty.
    * 
    * @throws PSModelException If any problems while communicating with the
    * server.
    * @throws PSHierarchyDefinitionException If the definition is found to be
    * incorrect.
    */
   private List<PSUiReference> buildChildReferences(PSUiReference parent,
         String sortType, List<Node> nodes, List<Catalog> catalogs,
         InheritedProperties inheritedProps, IPSReference child, boolean force)
      throws PSModelException, PSHierarchyDefinitionException
   {
      List<PSUiReference> results = new ArrayList<PSUiReference>();
      if (nodes != null && nodes.size() > 0)
      {
         for (Node type : nodes)
         {
            results.add(createNodesFromNodeDef(parent, type, inheritedProps,
                  force));
         }
      }

      if (catalogs != null && catalogs.size() > 0)
      {
         for (Catalog type : catalogs)
         {
            results.addAll(createNodesFromCatalogDef(parent, type,
                  inheritedProps, child, force));
         }
      }
      if (sortType == null || sortType.trim().length() == 0)
         sortType = "ascending";
      if (sortType.equalsIgnoreCase("descending"))
         sort(results, false);
      else if (sortType.equalsIgnoreCase("ascending") || catalogs.size() > 0)
         sort(results, true);
      // else document order
      return results;
   }

   /**
    * Order the supplied list in ascending or descending order. Folders
    * are grouped at the top for ascending and the bottom for descending (like
    * Windows explorer.)
    * 
    * @param results Assumed not <code>null</code>. The list is modified to
    * be in sorted order.
    * 
    * @param ascending Indicates what order is desired.
    */
   private void sort(List<PSUiReference> results, boolean ascending)
   {
      List<PSUiReference> folders = new ArrayList<PSUiReference>();
      List<PSUiReference> leaves = new ArrayList<PSUiReference>();
      for (PSUiReference ref : results)
      {
         if (ref.isFolder())
            folders.add(ref);
         else
            leaves.add(ref);
      }
      results.clear();
      if (ascending)
      {
         Collections.sort(folders);
         Collections.sort(leaves);
         results.addAll(folders);
         results.addAll(leaves);
      }
      else
      {
         Collections.sort(folders, Collections.reverseOrder());
         Collections.sort(leaves, Collections.reverseOrder());
         results.addAll(leaves);
         results.addAll(folders);
      }
   }

   /**
    * Build the UI references for each child cataloged for the supplied parent.
    * No sorting is done.
    * 
    * @param parent May be <code>null</code>.
    * 
    * @param catalogDef The section of the definition that defines how the
    * children for the parent are obtained. Assumed not <code>null</code>.
    * 
    * @param inheritedProps Properties from enclosing ancestors. May be
    * <code>null</code>.
    * 
    * @param child If supplied, this is used as the new children instead of
    * cataloging. It is assumed that this is a real instance as defined by the
    * {@link PSUiReference#isReference()} method returning <code>false</code>.
    * 
    * @param force If <code>true</code>, then the catalog will query the
    * server, even if the request could have been serviced from the cache. It is
    * ignored if <code>child</code> is supplied.
    * 
    * @return Never <code>null</code>, may be empty.
    * 
    * @throws PSModelException If any problems communicating with the server.
    * @throws PSHierarchyDefinitionException If the definition is improper.
    */
   private Collection<PSUiReference> createNodesFromCatalogDef(
         PSUiReference parent, Catalog catalogDef,
         InheritedProperties inheritedProps, IPSReference child, boolean force)
      throws PSModelException, PSHierarchyDefinitionException
   {
      InheritedProperties processedProps;
      if (inheritedProps == null)
      {
         processedProps = new InheritedProperties(catalogDef.getAllowedTypes(),
               catalogDef.getCatalogProperty());
      }
      else
      {
         processedProps = inheritedProps.inherit(catalogDef
            .getAllowedTypes(), catalogDef.getCatalogProperty());
      }
      if (catalogDef.getType().equalsIgnoreCase(CT_OBJECT))
      {
         final IPSCmsModel model =
            PSCoreFactory.getInstance().getModel(catalogDef.getName());

         final List<PSUiReference> results = new ArrayList<PSUiReference>();
         /*
          * assume that any catalogs of this type are the real mccoy, i.e.
          * isReference is false
          */
         if (model.isHierarchyModel()
               && (child == null || child instanceof IPSHierarchyNodeRef))
         {
            final Collection<IPSHierarchyNodeRef> refs;
            if (child == null)
            {
               if (parent == null || parent.getReference() == null)
               {
                  String treeName = null;
                  if (parent != null)
                  {
                     Object val = parent.getProperty(TREE_PROPNAME);
                     if (val != null && !StringUtils.isBlank(val.toString()))
                        treeName = val.toString();
                  }
                  if (treeName == null)
                  {
                     Collection<String> treeNames = model
                           .getHierarchyTreeNames();
                     if (treeNames.size() != 1)
                     {
                        if (parent == null)
                        {
                           throw new PSHierarchyDefinitionException(
                                 "Hierarchy models w/ more than 1 tree name are not allowed at the root.");
                        }
                        throw new PSHierarchyDefinitionException(
                              "Must specify the attribute 'treeName' for the <Node> element when it allows USER_FILE children.");
                     }
                     treeName = treeNames.iterator().next();
                  }
                  final IPSHierarchyManager mgr = model
                        .getHierarchyManager(treeName);
                  refs = mgr.getChildren(null, force);
               }
               else
               {
                  final IPSHierarchyManager mgr = model
                        .getHierarchyManager(parent.getReference());
                  refs = mgr.getChildren((IPSHierarchyNodeRef) parent
                        .getReference(), force);
               }
            }
            else
            {
               refs = Collections.singleton((IPSHierarchyNodeRef)child); 
            }
               
            for (IPSHierarchyNodeRef ref : refs)
            {
               final IPSCatalogFactory childrenSource = createCatalogFactory(
                     ref.getObjectType(), catalogDef, processedProps);
               final LabelSource labelSource = 
                  mapDisplayLabelSource(catalogDef.getDisplayLabelSource());
               final PSUiReference node = new PSUiReference(parent, ref,
                     childrenSource, catalogDef.isIsReference(),
                     ref.isContainer(), labelSource, null);
               setNodeHandler(node, catalogDef, processedProps);
               
               Enum secondaryType = ref.getObjectType().getSecondaryType();
               if (secondaryType != null
                     && secondaryType
                           .equals(PSObjectTypes.UserFileSubTypes.PLACEHOLDER))
               {
                  node.setProperty(INHERITED_PROPS_PROPNAME, inheritedProps);
               }
               results.add(node);
            }
         }
         else
         {
            final Collection<IPSReference> refs = child == null
                  ? model.catalog(force)
                  : Collections.singleton(child);  
            for (IPSReference ref : refs)
            {
               final PSUiReference node = new PSUiReference(
                     parent,
                     ref,
                     createCatalogFactory(ref.getObjectType(), catalogDef,
                           processedProps),
                     catalogDef.isIsReference(),
                     false,
                     mapDisplayLabelSource(catalogDef.getDisplayLabelSource()),
                     null);
               setNodeHandler(node, catalogDef, processedProps);
               results.add(node);
            }
         }
         for (PSUiReference node : results)
         {
            //only type supported for catalog nodes
            node.setSortOrder(SortOrder.ASCENDING);
         }
         return results;
      }
      else if (catalogDef.getType().equalsIgnoreCase("class"))
      {
         IPSCatalogFactory factory = (IPSCatalogFactory) loadCatalogClass(
               catalogDef.getName(), IPSCatalogFactory.class,
               processedProps, catalogDef);
         if (child == null)
         {
            return factory.createCatalog(parent).getEntries(force);
         }
         return Collections.singletonList(factory.createCatalog(parent)
               .createEntry(child));
      }
      else
      {
         // schema should prevent this
         throw new PSHierarchyDefinitionException(
               "The 'type' attribute of the <Catalog> element must be either 'object' or 'class'.");
      }
   }

   /**
    * Combines the catalog def w/ the instance tree of the supplied node and
    * uses the resulting info to find and load a handler.
    * 
    * @param node The handler will be set on this node. Assumed not
    * <code>null</code>.
    * 
    * @param catalogDef The definition for this node, may be <code>null</code>.
    * 
    * @param inheritedProps The properties from ancestors in the definition.
    * May be <code>null</code>.
    * 
    * @throws PSHierarchyDefinitionException If a handler class was defined in
    * the definition file, but that class could not be loaded.
    */
   private void setNodeHandler(final PSUiReference node,
         Catalog catalogDef, InheritedProperties inheritedProps)
      throws PSHierarchyDefinitionException
   {
      InstanceTree fragDef = node.getObjectType() != null ? getInstanceTree(node
            .getObjectType())
            : null;
      
      Handler handlerDef = null;
      if (catalogDef != null && catalogDef.getHandler() != null)
      {
         handlerDef = catalogDef.getHandler();
      }
      else if (fragDef != null && (catalogDef == null
            || catalogDef.isDefaultInstanceTree()))
      {
         handlerDef = fragDef.getHandler();
      }
      
      InheritedProperties processedProps = inheritedProps;
      if (catalogDef != null)
      {
         processedProps = inheritedProps.inherit(null, catalogDef
               .getCatalogProperty());
      }
      loadAndConfigureHandler(node, handlerDef, processedProps);
   }
   
   /**
    * Attempts to load the handler based on the supplied def. If successful,
    * the handler is configured and set on the supplied node.
    * 
    * @param node Assumed not <code>null</code>.
    * @param handlerDef Assumed not <code>null</code>.
    * @param props Properties from ancestor nodes. May be <code>null</code>.
    * @throws PSHierarchyDefinitionException If problems loading the specified
    * handler.
    */
   private void loadAndConfigureHandler(PSUiReference node,
         Handler handlerDef, InheritedProperties props)
      throws PSHierarchyDefinitionException
   {
      final IPSDeclarativeNodeHandler handler = loadHandlerClass(handlerDef,
            props);
      if (handler != null)
      {
         HandlerOptionSet config = HandlerOptions.getAllOptions();
         if (!handlerDef.isCopyable())
            config.removeOptionFlag(HandlerOptions.COPYABLE);
         if (!handlerDef.isDeletable())
            config.removeOptionFlag(HandlerOptions.DELETABLE);
         if (!handlerDef.isPasteable())
            config.removeOptionFlag(HandlerOptions.PASTEABLE);
         if (!handlerDef.isRenamable())
            config.removeOptionFlag(HandlerOptions.RENAMABLE);
         if (!handlerDef.isSecurable())
            config.removeOptionFlag(HandlerOptions.SECURABLE);
         handler.configure(config);
         node.setHandler(handler);
      }
   }

   /**
    * Checks if a handler name is present in the def, and if so, attempts to
    * load it.
    * 
    * @param handlerDef The definition of the handler for some node. If
    * <code>null</code> or the associated class is empty, returns immediately.
    * 
    * @param props These are passed to the ctor. May be <code>null</code>.
    * 
    * @return If no class name is specified, <code>null</code> is returned.
    * Otherwise, an attempt is made to load and instantiate the handler class
    * specified in the def.
    * 
    * @throws ClassCastException If the class found in the def is not a node
    * handler.
    * 
    * @throws PSHierarchyDefinitionException If the class is specified and can't
    * be loaded for any reason or the <code>objectTypeStrings</code> cannot be
    * converted to a {@link PSObjectType}.
    */
   private IPSDeclarativeNodeHandler loadHandlerClass(Handler handlerDef, 
         InheritedProperties props)
      throws PSHierarchyDefinitionException
   {
      if (handlerDef == null)
         return null;
      String className = handlerDef.getClassName();
      if (StringUtils.isBlank(className))
         className = PSIconNodeHandler.class.getName();

      InheritedProperties processedProps;
      if (props == null)
      {
         processedProps = new InheritedProperties(
               handlerDef.getAllowedTypes(), null);
      }
      else
         processedProps = props.inherit(handlerDef.getAllowedTypes(), null);
      try
      {
         Class clazz = Class.forName(className);
         Constructor ctor = clazz.getConstructor(new Class[] {
               Properties.class, String.class, PSObjectType[].class });
         Collection<PSObjectType> aType = processedProps.getAllowedTypes();
         Object o = ctor.newInstance(new Object[] {
               processedProps.getCatalogProps(), handlerDef.getIconPath(),
               aType.toArray(new PSObjectType[aType.size()]) });
         return (IPSDeclarativeNodeHandler) o;
      }
      catch (Exception e)
      {
         // since there are so many and we do the same for all, catch them all         
         String[] errorArgs = { className, e.getClass().getName(),
               e.getLocalizedMessage() };
         if (e instanceof InvocationTargetException)
         {
            InvocationTargetException tmp = (InvocationTargetException) e;
            errorArgs[1] = tmp.getTargetException().getClass().getName();
            errorArgs[2] = tmp.getTargetException().getLocalizedMessage();
         }
         throw new PSHierarchyDefinitionException(
               "The handler class ''{0}'' failed to load for the following reason: {1} - {2}",
               errorArgs);
      }
   }

   /**
    * Converts each entry in the supplied list to the proper type. Each entry
    * should be of a form as generated by the {@link PSObjectType#toSerial()}
    * method.
    * 
    * @param allowedTypeStrings If <code>null</code> or empty, returns
    * immediately with an empty array.
    * 
    * @return An array whose length is equal to the size of the supplied list.
    * 
    * @throws PSHierarchyDefinitionException If the strings cannot be converted
    * to a type.
    */
   private PSObjectType[] convertStringToObjectType(
         Collection<String> allowedTypeStrings)
      throws PSHierarchyDefinitionException
   {
      if (null == allowedTypeStrings || allowedTypeStrings.size() == 0)
         return new PSObjectType[0];
      
      PSObjectType[] results = new PSObjectType[allowedTypeStrings.size()];
      int i = 0;
      for (String serializedForm : allowedTypeStrings)
      {
         try
         {
            results[i++] = new PSObjectType(serializedForm);
         }
         catch (RuntimeException e)
         {
            throw new PSHierarchyDefinitionException(e.getLocalizedMessage());
         }
      }
      return results;
   }
   
   /**
    * This is the standard factory used if no other factory is specified. See
    * the ctor for more details.
    *
    * @author paulhoward
    */
   private class DefaultCatalogFactory implements IPSCatalogFactory
   {
      /**
       * Creates a factory that knows how to create a cataloger that can 
       * generate nodes as defined declaratively in an xml file.
       * 
       * @param nodes The Node element definitions for this factory. These
       * define the declarative nodes generated by this factory. May be
       * <code>null</code> or empty.
       * 
       * @param catalogs The Catalog element definitions for this factory. These
       * define how to dynamically lookup the nodes. May be <code>null</code>
       * or empty.
       * 
       * @param inheritedProps These are properties that have been inherited
       * from ancestor nodes in the definition. May be <code>null</code> or
       * empty.
       */
      public DefaultCatalogFactory(List<Node> nodes,
            List<Catalog> catalogs,
            final InheritedProperties inheritedProps)
      {
         m_nodes = nodes;
         m_catalogs = catalogs;
         m_inheritedProps = inheritedProps;
      }
      
      //see interface
      public IPSCatalog createCatalog(PSUiReference parent)
      {
         m_parent = parent;
         IPSCatalog cat = new IPSCatalog()
         {
            //see interface
            public PSUiReference createEntry(IPSReference ref)
            {
               if ( null == ref)
               {
                  throw new IllegalArgumentException("ref cannot be null");  
               }
               try
               {
                  return buildChildReferences(m_parent, null, m_nodes,
                        m_catalogs, m_inheritedProps, ref, false).get(0);
               }
               catch (PSHierarchyDefinitionException e)
               {
                  // this is a bug if this happens
                  throw new RuntimeException(e);
               }
               catch (PSModelException e)
               {
                  // shouldn't have to communicate w/ server
                  throw new RuntimeException(e);
               }
            }
            
            //see interface
            public List<PSUiReference> getEntries(boolean force)
               throws PSModelException
            {
               try
               {
                  return buildChildReferences(m_parent, null, m_nodes,
                        m_catalogs, m_inheritedProps, null, force);
               }
               catch (PSHierarchyDefinitionException e)
               {
                  // this is a bug if this happens
                  throw new RuntimeException(e);
               }
            }

         };
         return cat;
      }

      //see Object
      @Override
      public boolean equals(Object o)
      {
         if (o == null)
            return false;
         if (!(o instanceof DefaultCatalogFactory))
            return false;
         if (o == this)
            return true;
         DefaultCatalogFactory rhs = (DefaultCatalogFactory) o;
         //only check the path to prevent an infinite loop
         boolean result = new EqualsBuilder()
            .append(m_nodes, rhs.m_nodes)
            .append(m_catalogs, rhs.m_catalogs)
            .append(m_inheritedProps, rhs.m_inheritedProps)
            .isEquals();
         
         return result;
      }

      //see Object
      @Override
      public int hashCode()
      {
         return new HashCodeBuilder()
            .append(m_nodes)
            .append(m_catalogs)
            .append(m_inheritedProps)
            .toHashCode();
      }

      /**
       * See ctor for description.
       */
      private final List<Node> m_nodes;

      /**
       * See ctor for description.
       */
      private final List<Catalog> m_catalogs;

      /**
       * See ctor for description.
       */
      private final InheritedProperties m_inheritedProps;

      /**
       * The param supplied to the {@link #createCatalog(PSUiReference)} method.
       * For use by the inner class that method creates.
       */
      private PSUiReference m_parent;
   }

   /**
    * Looks at the children of the supplied definition and initializes a factory
    * that is capable of generating the children as defined. The InstanceTree
    * for the supplied type is taken into account.
    * 
    * @param parentObjectType The data type of the reference for which the
    * factory is being created. It is used to match InstanceTree templates if
    * the current definition has no children defined. May be <code>null</code>.
    * 
    * @param catalogDef May be <code>null</code>, in which case only the
    * InstanceTree definition is considered.
    * 
    * @param inheritedProps These are passed on the the generated factory to
    * include with the properties associated with <code>catalogDef</code>. It
    * should contain properties of containing ancestors. May be
    * <code>null</code>.
    * 
    * @return If the supplied def needs a catalog, a valid one is returned,
    * otherwise, <code>null</code> is returned.
    */
   public IPSCatalogFactory createCatalogFactory(PSObjectType parentObjectType,
         final Catalog catalogDef, final InheritedProperties inheritedProps)
   {
      final List<Node> nodes = new ArrayList<Node>();
      final List<Catalog> catalogs = new ArrayList<Catalog>();
      if (catalogDef != null)
      {
         nodes.addAll(catalogDef.getNode());
         catalogs.addAll(catalogDef.getCatalog());
      }
      
      if (nodes.size() == 0 && catalogs.size() == 0)
      {
         // see if there is an InstanceTree and use that def instead
         boolean match = false;
         if ((catalogDef == null || catalogDef.isDefaultInstanceTree())
               && parentObjectType != null)
         {
            InstanceTree fragDef = getInstanceTree(parentObjectType);
               
            if (fragDef != null)
            {
               match = true;
               if (fragDef.getNode() != null)
                  nodes.addAll(fragDef.getNode());
               if (fragDef.getCatalog() != null)
                  catalogs.addAll(fragDef.getCatalog());
            }
         }
         if (!match || ((nodes.size() == 0) && (catalogs.size() == 0)))
         {
            return null;
         }
      }

      return new DefaultCatalogFactory(nodes, catalogs, inheritedProps);
   }

   /**
    * Creates a new folder node based on the supplied params.
    * 
    * @param parent The nearest ancestor of the new node. May be
    * <code>null</code> if this node is in the root.
    * 
    * @param name The name of the folder. Never <code>null</code> or empty.
    * 
    * @param description A brief tooltip. May be <code>null</code> or empty.
    * 
    * @param inheritedProps Properties from ancestor nodes in the definition.
    * May be <code>null</code>.
    * 
    * @param catalogDef The catalog definition for this node. May be
    * <code>null</code> if there isn't one.
    * 
    * @param data A data object to be stored in the generated node. May be
    * <code>null</code>.
    * 
    * @return Never <code>null</code>.
    */
   public PSUiReference createFolderNode(PSUiReference parent, String name,
         String description, InheritedProperties inheritedProps,
         Catalog catalogDef, Object data) 
   {
      if (StringUtils.isBlank(name))
      {
         throw new IllegalArgumentException("name cannot be null or empty");  
      }
      
      return new PSUiReference(parent, name, description, data,
            createCatalogFactory(null, catalogDef, inheritedProps), true);
   }
   
   /**
    * Creates a node wrapper for the supplied child using an instance tree def
    * that matches the type of the child. 
    * 
    * @param parent The parent of the newly created node. May be
    * <code>null</code> to create a root child.
    * @param child The handle to be wrapped. Never <code>null</code>.
    * @param inheritedProps Properties from ancestor nodes. May be
    * <code>null</code>.
    * @param catalogDef The catalog definition for nodes of this type. May be
    * <code>null</code>.
    * @return Never <code>null</code>.
    * 
    * @throws PSHierarchyDefinitionException If there is no instance tree def
    * for the supplied child or it is malformed.
    */
   public PSUiReference createNode(PSUiReference parent, IPSReference child,
         InheritedProperties inheritedProps, Catalog catalogDef)
      throws PSHierarchyDefinitionException
   {
      if (null == child)
      {
         throw new IllegalArgumentException("child cannot be null");  
      }
      
      InstanceTree fragDef = getInstanceTree(child.getObjectType());
      if (fragDef == null)
      {
         throw new PSHierarchyDefinitionException(
               "Could not find InstanceTree node where objectId=''{0}''",
               new String[] { child.getObjectType().toString() });
      }

      boolean isFolder = child instanceof IPSHierarchyNodeRef
            && ((IPSHierarchyNodeRef) child).isContainer();
      boolean isReference = catalogDef == null ? false : catalogDef
            .isIsReference(); 
      
      LabelSource labelSource = LabelSource.OBJECT_NAME;
      if (catalogDef != null 
            && !StringUtils.isBlank(catalogDef.getDisplayLabelSource()))
      {
         labelSource = mapDisplayLabelSource(catalogDef.getDisplayLabelSource());
      }
      else if (!StringUtils.isBlank(fragDef.getDisplayLabelSource()))
      {
         labelSource = mapDisplayLabelSource(fragDef.getDisplayLabelSource());
      }
      
      //createCatalogFactory picks up the instance tree if 2nd param is null
      final PSUiReference node = new PSUiReference(parent, child,
            createCatalogFactory(child.getObjectType(), catalogDef,
                  inheritedProps), isReference, isFolder, labelSource, null);
      setNodeHandler(node, catalogDef, inheritedProps);
      
      return node;
   }

   /**
    * Each object type may have an InstanceTree definition available. These
    * are accessed by design object type.
    * 
    * @param type The type for which you want to get an instance tree
    * definition. Never <code>null</code>.
    * 
    * @return A tree that has a type that matches the supplied ref, or
    * <code>null</code> if one is not found.
    */
   private InstanceTree getInstanceTree(PSObjectType type)
   {
      String typeString = type.getPrimaryType().name();
      if (type.getSecondaryType() != null)
      {
         typeString += ":" + type.getSecondaryType().name();
      }
         
      Iterator instanceDefs = m_treeDef.getInstanceTree().iterator();
      InstanceTree fragDef = null; 
      while (instanceDefs.hasNext())
      {
         InstanceTree instanceDef = (InstanceTree) instanceDefs.next();
         if (doesInstanceTreeSupportType(instanceDef, typeString))
         {
            fragDef = instanceDef;
            break;
         }
      }
      return fragDef;
   }

   /**
    * Walks all object ids for the supplied def and checks each one against the
    * supplied name.
    * 
    * @param def Assumed not <code>null</code>.
    * 
    * @param typeName Assumed not <code>null</code>.
    * 
    * @return <code>true</code> if a match is found (case-sensitive),
    * <code>false</code> otherwise.
    */
   private boolean doesInstanceTreeSupportType(InstanceTree def,
         String typeName)
   {
      if (def.getObjectIds() == null)
         return false;
      
      for (Object objectId : def.getObjectIds())
      {
         if (objectId.toString().equals(typeName))
            return true;
      }
      return false;
   }
   
   /**
    * Loads the specified file and then parses it into a TreeDef using the
    * JAXB classes. It is loaded using the getResource method.
    * 
    * @param source Assumed not <code>null</code>.
    * 
    * @return Never <code>null</code>.
    * 
    * @throws IOException
    */
   private TreeDef loadTree(Reader source)
      throws IOException
   {
      try
      {
         JAXBContext ctx = JAXBContext.newInstance(
               "com.percussion.workbench.ui.views.hierarchy.xmlbind");
         assert(ctx != null);
         Unmarshaller u = ctx.createUnmarshaller();
         TreeDef def = (TreeDef) u.unmarshal(new InputSource(source));
         source.close();
         return def;
      }
      catch (JAXBException e)
      {
         //this should never happen
         throw new RuntimeException("JAXB misconfigured: "
               + e.getLocalizedMessage());
      }
   }

   /**
    * Loads a class by name, converting any exception into the declared one.
    * 
    * @param className The fully qualified name of the class to load. Assumed
    * not <code>null</code> or empty.
    * 
    * @param requiredType If not <code>null</code>, the returned object is
    * guaranteed to be castable to this type or an exception is thrown.
    * 
    * @param catalogProps Passed as one of the params to the ctor. May be 
    * <code>null</code>.
    * 
    * @param typeDef Passed as one of the params to the ctor. Never
    * <code>null</code>.
    * 
    * @return Never <code>null</code>.
    * 
    * @throws PSHierarchyDefinitionException If the named class can't be loaded
    * for any reason.
    */
   private Object loadCatalogClass(String className, Class requiredType,
         InheritedProperties catalogProps, Catalog typeDef)
      throws PSHierarchyDefinitionException
   {
      try
      {
         Class clazz = Class.forName(className);
         Constructor ctor = clazz.getConstructor(new Class[] {
               InheritedProperties.class, getClass(),
               Catalog.class });
         Object o = ctor.newInstance(new Object[] { catalogProps,
               this, typeDef });
         if (requiredType != null)
            requiredType.cast(o);
         return o;
      }
      catch (Exception e)
      {
         Throwable t = e instanceof InvocationTargetException 
               ? ((InvocationTargetException) e).getTargetException() : e;
         // since there are so many and we do the same for all, catch them all
         String[] errorArgs = { className, t.getClass().getName(),
               t.getLocalizedMessage() };
         throw new PSHierarchyDefinitionException(
               "The catalog class ''{0}'' failed to load for the following reason: {1} - {2}",
               errorArgs);
      }
   }

   /**
    * Build the UI reference for the supplied node definition. These are nodes
    * that don't have design objects associated with them.
    * 
    * @param parent This becomes the parent of the returned node. May be
    * <code>null</code>.
    * 
    * @param nodeDef What the node looks and behaves like. Assumed not
    * <code>null</code>.
    * 
    * @param inheritedProps Properties from any enclosing ancestors. May be
    * <code>null</code>.
    * 
    * @param force If cataloging from the model is required, this flag is passed
    * thru. It controls whether data can be taken from the cache.
    * <code>true</code> requires the call to go to the server.
    * 
    * @return Never <code>null</code>.
    * 
    * @throws PSHierarchyDefinitionException If any classes specified in the
    * definition cannot be loaded instances instantiated.
    */
   private PSUiReference createNodesFromNodeDef(PSUiReference parent,
         Node nodeDef, InheritedProperties inheritedProps, boolean force)
      throws PSHierarchyDefinitionException
   {
      InheritedProperties processedProps;
      if (inheritedProps == null)
      {
         processedProps = new InheritedProperties(nodeDef.getAllowedTypes(),
               nodeDef.getCatalogProperty());
      }
      else
      {
         processedProps = inheritedProps.inherit(nodeDef
            .getAllowedTypes(), nodeDef.getCatalogProperty());
      }
      
      boolean isFolder = !(nodeDef.getCatalog().isEmpty()
            && nodeDef.getNode().isEmpty());
      
      IPSCatalogFactory factory = null;
      if (isFolder)
         factory = new Cataloger(nodeDef, processedProps);
      
      PSUiReference node;
      if (StringUtils.isBlank(nodeDef.getObjectId()))
      {
         node = new PSUiReference(parent, nodeDef.getLabelKey(),
            nodeDef.getDescription(), null, factory, isFolder);
      }
      else
      {
         try
         {
            //must be exactly 1 instance of this type of object
            PSObjectType otype = new PSObjectType(nodeDef.getObjectId());
            IPSCmsModel model = PSCoreFactory.getInstance().getModel(
                  otype.getPrimaryType());
            Collection<IPSReference> ref = model.catalog(force, otype);
            if (ref.size() != 1)
            {
               String template = 
                  "objectId attribute for node {0} requires exactly 1 instance. Found {1} instances.";
               throw new PSHierarchyDefinitionException(template,
                     new String[] { nodeDef.getLabelKey(),
                           String.valueOf(ref.size()) });
            }
            node = new PSUiReference(parent, ref.iterator().next(), null,
                  false, false, mapDisplayLabelSource(nodeDef
                        .getDisplayLabelSource()), nodeDef.getLabelKey());
         }
         catch (PSModelException e)
         {
            throw new RuntimeException(e);
         }
      }

      loadAndConfigureHandler(node, nodeDef.getHandler(), processedProps);
      node.setSortOrder(mapSortOrder(nodeDef.getSorting()));
      setNodeProperties(node, nodeDef.getNodeProperty());

      if (!StringUtils.isBlank(nodeDef.getTreeName()))
         node.setProperty(TREE_PROPNAME, nodeDef.getTreeName());
      if (nodeDef.getObjectHomeType() != null)
      {
         PSObjectType type = new PSObjectType(nodeDef.getObjectHomeType());
         IPSHomeNodeManager mgr = null;
         String name = nodeDef.getHomeTypeClassName();
         if (StringUtils.isNotBlank(name))
         {
            try
            {
               if (m_categoryManagers.get(name) != null)
                  mgr = m_categoryManagers.get(name);
               else
               {
                  mgr = (IPSHomeNodeManager) Class.forName(name).newInstance();
                  m_categoryManagers.put(name, mgr);
               }
            }
            catch (Exception e)
            {
               // since there are so many and we do the same for all, catch them
               // all
               String[] errorArgs = { name, e.getClass().getName(),
                     e.getLocalizedMessage() };
               throw new PSHierarchyDefinitionException(
                     "The category manager class ''{0}'' failed to load for the following reason: {1} - {2}",
                     errorArgs);
            }
         }

         Map<String,String> props = new HashMap();
         Properties p = processedProps.getCatalogProps();
         for (Enumeration e = p.propertyNames(); e.hasMoreElements();)
         {
            Object o = e.nextElement();
            props.put(o.toString(), p.getProperty(o.toString()));
         }
         node.setObjectHomeInfo(type, mgr, props);
      }
      return node;
   }

   /**
    * Processes the supplied set of name/value pairs, setting them into the 
    * supplied node.
    * 
    * @param node Assumed not <code>null</code>.
    * 
    * @param properties May be <code>null</code> or empty.
    */
   private void setNodeProperties(PSUiReference node,
         Collection<NodeProperty> properties)
   {
      if (properties == null || properties.size() == 0)
         return;
      for (NodeProperty prop : properties)
      {
         node.setProperty(prop.getName(), prop.getValue());
      }
   }

   /**
    * Converts the text representation to the proper enum by stripping '_' from 
    * the enum name before comparison.
    * 
    * @param displayLabelSource The text from the definition.
    * 
    * @return Never <code>null</code>.
    * 
    * @throws PSHierarchyDefinitionException If the supplied string does not
    * match the name of any existing label source enums.
    */
   private LabelSource mapDisplayLabelSource(String displayLabelSource)
      throws PSHierarchyDefinitionException
   {
      for (LabelSource e : LabelSource.values())
      {
         String text = e.name().replace("_", "");
         if (text.equalsIgnoreCase(displayLabelSource))
            return e;
      }

      throw new PSHierarchyDefinitionException(
            "Invalid value for displayLabelSource attribute: "
                  + displayLabelSource);
   }

   /**
    * Converts the supplied string to a matching enum from the
    * {@link PSUiReference} class.
    * 
    * @param sorting If empty or <code>null</code> or a match is not found,
    * <code>NONE</code> will be returned.
    * 
    * @return Never <code>null</code>.
    */
   private SortOrder mapSortOrder(String sorting)
   {
      if (StringUtils.isEmpty(sorting))
         return PSUiReference.SortOrder.NONE;

      if (sorting.equalsIgnoreCase(PSUiReference.SortOrder.ASCENDING.name()))
         return PSUiReference.SortOrder.ASCENDING;
      else if (sorting.equalsIgnoreCase(PSUiReference.SortOrder.DESCENDING
            .name()))
      {
         return PSUiReference.SortOrder.DESCENDING;
      }
      return PSUiReference.SortOrder.NONE;
   }

   /**
    * Passed to ctor of {@link PSUiReference}. Knows how to get the children
    * for a particular <code>Node</code>. <code>Catalog</code>s
    * use external classes as the catalog factory. Performs any work lazily.
    */
   private class Cataloger implements IPSCatalogFactory
   {
      /**
       * Only ctor.
       * 
       * @param nodeDef The container that will own the children generated by
       * this instance. Never <code>null</code>.
       * 
       * @param inheritedProps Only used if a child has a
       * <code>Catalog</code>, in which case, the inherited props are
       * passed to it along with any properties it contained itself. May be
       * <code>null</code>.
       */
      public Cataloger(Node nodeDef, InheritedProperties inheritedProps)
      {
         if (null == nodeDef)
         {
            throw new IllegalArgumentException("nodeDef cannot be null");
         }

         m_nodeDef = nodeDef;
         m_inheritedProps = inheritedProps;
      }

      /**
       * @inheritDoc
       * 
       * @param parent 
       */
      public IPSCatalog createCatalog(final PSUiReference parent)
      {
         IPSCatalog cat = new IPSCatalog()
         {
            public List<PSUiReference> getEntries(boolean force)
               throws PSModelException
            {
               try
               {
                  return buildChildReferences(parent, m_nodeDef.getSorting(),
                        Collections.unmodifiableList(m_nodeDef.getNode()), 
                        Collections.unmodifiableList(m_nodeDef.getCatalog()),
                        m_inheritedProps, null, force);
               }
               catch (PSHierarchyDefinitionException e)
               {
                  throw new RuntimeException(e);
               }
            }

            public PSUiReference createEntry(IPSReference ref)
            {
               try
               {
                  List<Catalog> catalogs = m_nodeDef.getCatalog();
                  List<Catalog> usableCatalogs = 
                     new ArrayList<Catalog>();
                  if (catalogs != null)
                  {
                     if (catalogs.size() > 1)
                     {
                        
                        //pick the matching catalog
                        for (Catalog ct : catalogs)
                        {
                           if (ct.getType().equals(CT_OBJECT))
                           {
                              for (PSObjectType otype : PSCoreFactory
                                    .getInstance().getModel(ct.getName())
                                    .getObjectTypes())
                              {
                                 if (ref.getObjectType().equals(otype))
                                 {
                                    usableCatalogs.add(ct);
                                 }
                              }
                           }
                           else
                           {
                              assert(ct.getType().equals(CT_CLASS));
                              List<String> specifiedTypes = ct
                                    .getCatalogObjectTypes();
                              if (specifiedTypes == null
                                    || specifiedTypes.isEmpty())
                              {
                                 usableCatalogs.add(ct);
                              }
                              else
                              {
                                 for (String t : specifiedTypes)
                                 if (ref.getObjectType().equals(
                                          new PSObjectType(t)))
                                 {
                                    usableCatalogs.add(ct);
                                 }
                              }
                           }
                        }
                     }
                     else
                        usableCatalogs.addAll(catalogs);
                  }
                  if (usableCatalogs.size() > 1)
                  {
                     String msg = MessageFormat.format(PSMessages.getString(
                        "PSHierarchyDefProcessor.error.toManyMatchingCatalogs"),
                        parent.getPath());
                     throw new RuntimeException(
                           new PSHierarchyDefinitionException(msg));
                  }
                  else if (usableCatalogs.isEmpty())
                  {
                     String msg = MessageFormat.format(PSMessages.getString(
                           "PSHierarchyDefProcessor.error.noMatchingCatalogs"),
                           parent.getPath(), ref.getObjectType());
                     throw new RuntimeException(
                           new PSHierarchyDefinitionException(msg));
                  }
                  return buildChildReferences(parent, m_nodeDef.getSorting(),
                        null, usableCatalogs, m_inheritedProps, ref,
                        false).get(0);
               }
               catch (PSModelException e)
               {
                  throw new RuntimeException(e);
               }
               catch (PSHierarchyDefinitionException e)
               {
                  throw new RuntimeException(e);
               }
            }
         };
         return cat;
      }

      @Override
      public boolean equals(Object o)
      {
         if (o == null)
            return false;
         if (!(o instanceof Cataloger))
            return false;
         if (o == this)
            return true;
         Cataloger rhs = (Cataloger) o;
         
         return new EqualsBuilder()
            .append(m_inheritedProps, rhs.m_inheritedProps)
            .append(m_nodeDef, rhs.m_nodeDef)
            .isEquals();
      }

      @Override
      public int hashCode()
      {
         return new HashCodeBuilder()
            .append(m_inheritedProps)
            .append(m_nodeDef)
            .toHashCode();
      }
      
      /**
       * The definition of how to create this UI node. Never <code>null</code>.
       */
      private final Node m_nodeDef;

      /**
       * These are passed on when building catalogers for child nodes. They
       * should include properties for all enclosing ancestors.
       */
      private final InheritedProperties m_inheritedProps;
   }

   /**
    * Contains the definition of how this processor should build a tree. Never
    * <code>null</code>.
    */
   private final TreeDef m_treeDef;

   /**
    * Stores instances of category managers that have been previously cataloged
    * so new nodes that need the same class don't duplicate them. Never 
    * <code>null</code>, may be empty.
    */
   private Map<String, IPSHomeNodeManager> m_categoryManagers =
      new HashMap<String, IPSHomeNodeManager>();

   /**
    * See the ctor for a description.
    */
   private final String m_name;

   /**
    * One of the possible values for the 'type' attribute of the 'Catalog'
    * element. See the dtd for semantic meaning.
    */
   private static String CT_OBJECT = "object";

   /**
    * One of the possible values for the 'type' attribute of the 'Catalog'
    * element. See the dtd for semantic meaning.
    */
   private static final String CT_CLASS = "class";
}
